<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>YAKA Guest Assistant</title>

  <style>
    :root{
      --yaka-red: #7a1315;
      --yaka-grey: #cececd;
      --yaka-dark: #161616;

      --card: rgba(22,22,22,0.78);
      --card-border: rgba(206,206,205,0.18);
      --text: var(--yaka-grey);
      --muted: rgba(206,206,205,0.75);
      --shadow: 0 18px 45px rgba(0,0,0,0.45);

      --input-bg: rgba(206,206,205,0.08);
      --input-border: rgba(206,206,205,0.22);

      --me-bg: rgba(206,206,205,0.10);
      --me-border: rgba(206,206,205,0.24);

      --bot-bg: rgba(122,19,21,0.12);
      --bot-border: rgba(122,19,21,0.35);
    }

    * { box-sizing: border-box; }

    body{
      margin:0;
      font-family: Arial, sans-serif;
      background: var(--yaka-dark);
      color: var(--text);
      min-height: 100vh;
      background-image:
        radial-gradient(900px 520px at 10% 5%, rgba(122,19,21,0.35), transparent 55%),
        radial-gradient(900px 520px at 90% 15%, rgba(206,206,205,0.14), transparent 55%),
        radial-gradient(700px 420px at 50% 120%, rgba(122,19,21,0.22), transparent 60%);
    }

    .wrap{
      max-width: 920px;
      margin: 0 auto;
      padding: 18px 14px 22px;
    }

    .card{
      border-radius: 22px;
      overflow: hidden;
      border: 1px solid var(--card-border);
      background: linear-gradient(180deg, rgba(22,22,22,0.86), rgba(22,22,22,0.72));
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .header{
      padding: 22px 18px 14px;
      text-align: center;
      position: relative;
    }

    .header::after{
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(900px 250px at 50% 0%, rgba(122,19,21,0.55), transparent 60%),
        radial-gradient(900px 250px at 50% 60%, rgba(206,206,205,0.10), transparent 60%);
      opacity: 0.9;
    }

    .brand{
      position: relative;
      z-index: 1;
      display: grid;
      place-items: center;
      gap: 10px;
    }

    .brand img{
      height: 200px;
      width: auto;
      display: block;
      filter: drop-shadow(0 12px 22px rgba(0,0,0,0.55));
    }

    .brand .tag{
      margin-top: -6px;
      font-size: 14px;
      color: rgba(206,206,205,0.82);
      letter-spacing: 0.8px;
      text-transform: uppercase;
    }

    /* NEW: language row */
    .lang-row{
      position: relative;
      z-index: 2;
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .lang-row label{
      font-size: 12px;
      color: rgba(206,206,205,0.80);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .lang-row select{
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(206,206,205,0.22);
      background: rgba(0,0,0,0.18);
      color: var(--yaka-grey);
      outline: none;
      min-width: 220px;
    }

    .sub{
      padding: 12px 18px;
      font-size: 13px;
      color: var(--muted);
      border-top: 1px solid rgba(206,206,205,0.10);
      border-bottom: 1px solid rgba(206,206,205,0.10);
      background: rgba(0,0,0,0.08);
    }

    .status{
      padding: 10px 18px;
      font-size: 12px;
      color: var(--muted);
      border-bottom: 1px solid rgba(206,206,205,0.10);
      background: rgba(0,0,0,0.10);
    }

    .pill{
      display: inline-block;
      padding: 5px 10px;
      border-radius: 999px;
      margin-right: 8px;
      border: 1px solid rgba(206,206,205,0.22);
      background: rgba(206,206,205,0.08);
      color: rgba(206,206,205,0.92);
    }

    .chat{
      padding: 16px 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: 60vh;
      overflow-y: auto;
      background:
        radial-gradient(1000px 520px at 25% 0%, rgba(122,19,21,0.16), transparent 60%),
        radial-gradient(900px 520px at 90% 10%, rgba(206,206,205,0.08), transparent 55%),
        rgba(0,0,0,0.06);
    }

    .bubble{
      padding: 12px 14px;
      border-radius: 16px;
      max-width: 92%;
      line-height: 1.45;
      white-space: pre-wrap;
      word-wrap: break-word;
      border: 1px solid rgba(206,206,205,0.10);
      box-shadow: 0 10px 25px rgba(0,0,0,0.20);
    }

    .me{
      align-self: flex-end;
      background: var(--me-bg);
      border-color: var(--me-border);
    }

    .bot{
      align-self: flex-start;
      background: var(--bot-bg);
      border-color: var(--bot-border);
    }

    .bubble a{
      color: var(--yaka-grey);
      text-decoration: underline;
      text-underline-offset: 3px;
      word-break: break-word;
    }

    .meta{
      font-size: 11px;
      color: rgba(206,206,205,0.68);
      margin-top: 8px;
    }

    .input-area{
      padding: 14px 18px;
      border-top: 1px solid rgba(206,206,205,0.10);
      background: rgba(0,0,0,0.10);
    }

    .row{
      display:flex;
      gap: 8px;
      align-items: center;
    }

    #msg{
      flex:1;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid rgba(206,206,205,0.22);
      font-size: 16px;
      outline: none;
      background: rgba(206,206,205,0.08);
      color: var(--yaka-grey);
    }

    #msg::placeholder{
      color: rgba(206,206,205,0.55);
    }

    #msg:focus{
      border-color: rgba(122,19,21,0.70);
      box-shadow: 0 0 0 3px rgba(122,19,21,0.25);
    }

    button{
      padding: 12px 14px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      font-size: 15px;
      line-height: 1;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .06s ease, opacity .15s ease, box-shadow .15s ease;
    }

    button:active{ transform: translateY(1px); }

    .btn{
      background: var(--yaka-red);
      color: var(--yaka-grey);
      box-shadow: 0 10px 20px rgba(122,19,21,0.25);
      border: 1px solid rgba(206,206,205,0.14);
    }

    .btn.secondary{
      background: rgba(206,206,205,0.08);
      color: var(--yaka-grey);
      border: 1px solid rgba(206,206,205,0.22);
      box-shadow: none;
    }

    .btn:hover{ opacity: 0.92; }

    .btn:disabled{
      opacity: 0.6;
      cursor: not-allowed;
    }

    .hint{
      font-size: 12px;
      margin-top: 8px;
      color: rgba(206,206,205,0.70);
    }

    .small-btn{
      padding: 10px 12px;
      font-size: 14px;
      margin-right: 8px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">

      <div class="header">
        <div class="brand">
          <img src="/logo.png" alt="YAKA Residences Logo" />
          <div class="tag" id="tagText">Guest Assistant</div>

          <!-- NEW: Language selector -->
          <div class="lang-row">
            <label>
              <span id="langLabel">Language</span>
              <select id="langSelect" aria-label="Select language">
                <option value="en">English</option>
                <option value="si">‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω (Sinhala)</option>
                <option value="ta">‡Æ§‡ÆÆ‡Æø‡Æ¥‡Øç (Tamil)</option>
              </select>
            </label>
          </div>
        </div>
      </div>

      <div class="sub" id="subText">
        Ask questions about Wi-Fi, check-in/out, house rules, and nearby places.
      </div>

      <div class="status">
        <span class="pill" id="aptPill">Apartment: (not set)</span>
        <span class="pill" id="apiPill">API: checking‚Ä¶</span>
        <span class="pill" id="micPill">Mic: ready</span>
      </div>

      <div class="chat" id="chat"></div>

      <div class="input-area">
        <div class="row">
          <input id="msg" placeholder="Type or speak your question‚Ä¶" autocomplete="off" />
          <button class="btn secondary" id="micBtn" type="button" title="Voice question" aria-label="Voice question">üéôÔ∏è</button>
          <button class="btn" id="sendBtn" type="button">Send</button>
        </div>
        <div class="hint" id="hintText">
          Tip: Tap üéôÔ∏è to record, tap again to stop &amp; send. The bot can reply in your language and you can play replies aloud.
        </div>
      </div>

    </div>
  </div>

<script>
  const chatEl  = document.getElementById('chat');
  const msgEl   = document.getElementById('msg');
  const sendBtn = document.getElementById('sendBtn');
  const micBtn  = document.getElementById('micBtn');
  const aptPill = document.getElementById('aptPill');
  const apiPill = document.getElementById('apiPill');
  const micPill = document.getElementById('micPill');

  const tagText = document.getElementById('tagText');
  const subText = document.getElementById('subText');
  const hintText = document.getElementById('hintText');
  const langSelect = document.getElementById('langSelect');
  const langLabel = document.getElementById('langLabel');

  const params = new URLSearchParams(window.location.search);
  const apt = (params.get('apt') || '').trim();
  aptPill.textContent = apt ? `Apartment: ${apt}` : 'Apartment: (not set)';

  // ----------------------------
  // Language (multilingual UI)
  // ----------------------------
  const I18N = {
    en: {
      langLabel: "Language",
      tag: "Guest Assistant",
      sub: "Ask questions about Wi-Fi, check-in/out, house rules, and nearby places.",
      aptPrefix: "Apartment",
      apiChecking: "API: checking‚Ä¶",
      apiOk: "API: OK",
      apiNotReady: "API: not ready",
      apiOffline: "API: offline",
      micReady: "Mic: ready",
      micUnsupported: "Mic: unsupported",
      micNeedsHttps: "Mic: needs HTTPS",
      micRecording: "Mic: recording‚Ä¶",
      micTranscribing: "Mic: transcribing‚Ä¶",
      micError: "Mic: error",
      placeholder: "Type or speak your question‚Ä¶",
      send: "Send",
      tip: "Tip: Tap üéôÔ∏è to record, tap again to stop & send. You can type or speak in your selected language. Replies can be read aloud.",
      greet: "Hi! Ask me anything about your stay ‚Äî Wi-Fi, check-in/out, house rules, and local tips.",
      missingApt: "This page needs an apartment code. Example: ?apt=YAKA01",
      missingAptLong: "This link is missing an apartment code. Please scan the apartment QR code or open with ?apt=YAKA01.",
      speak: "üîä Speak",
      stop: "‚èπ Stop",
      generating: "Generating‚Ä¶",
      ttsFail: "Could not play voice.",
      recNotSupported: "Voice recording is not supported on this browser. Please type your question instead.",
      httpsRequired: "Microphone needs HTTPS on mobiles. Use your Azure HTTPS URL (not HTTP).",
      sttFail: "STT failed. Please try again or type your question."
    },
    si: {
      langLabel: "‡∂∑‡∑è‡∑Ç‡∑è‡∑Ä",
      tag: "‡∂Ö‡∂∏‡∑î‡∂≠‡∑ä‡∂≠‡∂±‡∑ä ‡∑É‡∑Ñ‡∑è‡∂∫‡∂ö‡∂∫",
      sub: "Wi-Fi, check-in/out, house rules ‡∑É‡∑Ñ ‡∂Ö‡∑Ä‡∂ß ‡∑É‡∑ä‡∂Æ‡∑è‡∂± ‡∂ú‡∑ê‡∂± ‡∂¥‡∑ä‚Äç‡∂ª‡∑Å‡∑ä‡∂± ‡∂Ö‡∑Ñ‡∂±‡∑ä‡∂±.",
      aptPrefix: "Apartment",
      apiChecking: "API: ‡∂¥‡∂ª‡∑ì‡∂ö‡∑ä‡∑Ç‡∑è ‡∂ö‡∂ª‡∂∏‡∑í‡∂±‡∑ä‚Ä¶",
      apiOk: "API: OK",
      apiNotReady: "API: ‡∑É‡∑ñ‡∂Ø‡∑è‡∂±‡∂∏‡∑ä ‡∂±‡∑ê‡∑Ñ‡∑ê",
      apiOffline: "API: offline",
      micReady: "Mic: ready",
      micUnsupported: "Mic: unsupported",
      micNeedsHttps: "Mic: HTTPS ‡∂Ö‡∑Ä‡∑Å‡∑ä‚Äç‡∂∫‡∂∫‡∑í",
      micRecording: "Mic: record ‡∂ö‡∂ª‡∂∏‡∑í‡∂±‡∑ä‚Ä¶",
      micTranscribing: "Mic: ‡∂Ω‡∑í‡∂∫‡∂∏‡∑í‡∂±‡∑ä‚Ä¶",
      micError: "Mic: error",
      placeholder: "Type ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∑Ñ‡∑ù ‡∂ö‡∂≠‡∑è ‡∂ö‡∂ª‡∂Ω‡∑è ‡∂Ö‡∑Ñ‡∂±‡∑ä‡∂±‚Ä¶",
      send: "‡∂∫‡∑Ä‡∂±‡∑ä‡∂±",
      tip: "‡∂â‡∂ü‡∑í‡∂∫: üéôÔ∏è ‡∂î‡∂∂‡∑è record ‡∂ö‡∂ª‡∂±‡∑ä‡∂±, ‡∂±‡∑ê‡∑Ä‡∂≠ ‡∂î‡∂∂‡∂Ω‡∑è stop ‡∂ö‡∂ª‡∂Ω‡∑è ‡∂∫‡∑Ä‡∂±‡∑ä‡∂±. ‡∂î‡∂∂‡∑ö ‡∂≠‡∑ù‡∂ª‡∑è‡∂ú‡∂≠‡∑ä ‡∂∑‡∑è‡∑Ç‡∑è‡∑Ä‡∑ô‡∂±‡∑ä type ‡∑Ñ‡∑ù ‡∂ö‡∂≠‡∑è ‡∂ö‡∂ª‡∂±‡∑ä‡∂±. ‡∂¥‡∑í‡∑Ö‡∑í‡∂≠‡∑î‡∂ª‡∑î ‡∑Å‡∂∂‡∑ä‡∂Ø‡∂∫‡∑ô‡∂±‡∑ä ‡∂Ö‡∑Ñ‡∂±‡∑ä‡∂±‡∂≠‡∑ä ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä.",
      greet: "‡∂Ü‡∂∫‡∑î‡∂∂‡∑ù‡∑Ä‡∂±‡∑ä! ‡∂î‡∂∂‡∑ö ‡∂±‡∑Ä‡∑è‡∂≠‡∑ê‡∂±‡∑ä ‡∂ú‡∑ê‡∂± ‡∂ï‡∂±‡∑ë‡∂∏ ‡∂Ø‡∑ô‡∂∫‡∂ö‡∑ä ‡∂Ö‡∑Ñ‡∂±‡∑ä‡∂± ‚Äî Wi-Fi, check-in/out, house rules, ‡∑É‡∑Ñ local tips.",
      missingApt: "‡∂∏‡∑ô‡∂∏ ‡∂¥‡∑í‡∂ß‡∑î‡∑Ä‡∂ß apartment code ‡∂ë‡∂ö ‡∂Ö‡∑Ä‡∑Å‡∑ä‚Äç‡∂∫‡∂∫‡∑í. ‡∂ã‡∂Ø‡∑è: ?apt=YAKA01",
      missingAptLong: "‡∂∏‡∑ô‡∂∏ ‡∂Ω‡∑í‡∂±‡∑ä‡∂ö‡∑ä ‡∂ë‡∂ö‡∂ß apartment code ‡∂ë‡∂ö ‡∂±‡∑ê‡∑Ñ‡∑ê. ‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª apartment QR code ‡∂ë‡∂ö scan ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∑Ñ‡∑ù ?apt=YAKA01 ‡∑É‡∂∏‡∂ü ‡∑Ä‡∑í‡∑Ä‡∑ò‡∂≠ ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.",
      speak: "üîä ‡∂ö‡∂Æ‡∂±‡∂∫",
      stop: "‚èπ ‡∂±‡∑Ä‡∂≠‡∑ä‡∑Ä‡∂±‡∑ä‡∂±",
      generating: "‡∂≠‡∑ê‡∂±‡∑ô‡∂±‡∑Ä‡∑è‚Ä¶",
      ttsFail: "‡∑Å‡∂∂‡∑ä‡∂Ø‡∂∫ play ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂∂‡∑ê‡∑Ñ‡∑ê.",
      recNotSupported: "‡∂∏‡∑ô‡∂∏ browser ‡∂ë‡∂ö‡∑ö voice recording support ‡∂±‡∑ê‡∑Ñ‡∑ê. ‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª type ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.",
      httpsRequired: "‡∂∏‡∑ú‡∂∂‡∂∫‡∑í‡∂Ω‡∑ä ‡∑Ä‡∂Ω microphone ‡∑É‡∂Ø‡∑Ñ‡∑è HTTPS ‡∂Ö‡∑Ä‡∑Å‡∑ä‚Äç‡∂∫‡∂∫‡∑í. Azure HTTPS URL ‡∂ë‡∂ö ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∑è ‡∂ö‡∂ª‡∂±‡∑ä‡∂±.",
      sttFail: "Voice to text ‡∑Ä‡∑ê‡∂© ‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∂±‡∑ê‡∑Ä‡∂≠ ‡∂ã‡∂≠‡∑ä‡∑É‡∑è‡∑Ñ ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∑Ñ‡∑ù type ‡∂ö‡∂ª‡∂±‡∑ä‡∂±."
    },
    ta: {
      langLabel: "‡ÆÆ‡Øä‡Æ¥‡Æø",
      tag: "‡Æµ‡Æø‡Æ∞‡ØÅ‡Æ®‡Øç‡Æ§‡Æø‡Æ©‡Æ∞‡Øç ‡Æâ‡Æ§‡Æµ‡Æø‡ÆØ‡Ææ‡Æ≥‡Æ∞‡Øç",
      sub: "Wi-Fi, check-in/out, house rules ‡ÆÆ‡Æ±‡Øç‡Æ±‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ∞‡ØÅ‡Æï‡Æø‡Æ≤‡ØÅ‡Æ≥‡Øç‡Æ≥ ‡Æá‡Æü‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ™‡Æ±‡Øç‡Æ±‡Æø ‡Æï‡Øá‡Æ≥‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç.",
      aptPrefix: "Apartment",
      apiChecking: "API: ‡Æö‡Æ∞‡Æø‡Æ™‡Ææ‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æø‡Æ±‡Æ§‡ØÅ‚Ä¶",
      apiOk: "API: OK",
      apiNotReady: "API: ‡Æ§‡ÆØ‡Ææ‡Æ∞‡Æø‡Æ≤‡Øç‡Æ≤‡Øà",
      apiOffline: "API: offline",
      micReady: "Mic: ready",
      micUnsupported: "Mic: unsupported",
      micNeedsHttps: "Mic: HTTPS ‡Æ§‡Øá‡Æµ‡Øà",
      micRecording: "Mic: ‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Øç‡Æï‡Æø‡Æ±‡Æ§‡ØÅ‚Ä¶",
      micTranscribing: "Mic: ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡ØÅ‡Æï‡Æø‡Æ±‡Æ§‡ØÅ‚Ä¶",
      micError: "Mic: error",
      placeholder: "‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æï‡Øá‡Æ≥‡Øç‡Æµ‡Æø‡ÆØ‡Øà ÿ™ÿß€å‡Æ™‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æµ‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ‡Æ™‡Øá‡Æö‡Æµ‡ØÅ‡ÆÆ‡Øç‚Ä¶",
      send: "Send",
      tip: "‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ: üéôÔ∏è ‡Æê ‡Æ§‡Æü‡Øç‡Æü‡Æø‡Æ™‡Øç ‡Æ™‡Æ§‡Æø‡Æµ‡ØÅ ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æµ‡ØÅ‡ÆÆ‡Øç; ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡Æ§‡Æü‡Øç‡Æü‡Æø ‡Æ®‡Æø‡Æ±‡ØÅ‡Æ§‡Øç‡Æ§‡Æø ‡ÆÖ‡Æ©‡ØÅ‡Æ™‡Øç‡Æ™‡Æµ‡ØÅ‡ÆÆ‡Øç. ‡Æ®‡ØÄ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ§‡Øá‡Æ∞‡Øç‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Øä‡Æ¥‡Æø‡ÆØ‡Æø‡Æ≤‡Øç ÿ™ÿß€å‡Æ™‡Øç/‡Æ™‡Øá‡Æö‡Æ≤‡Ææ‡ÆÆ‡Øç. ‡Æ™‡Æ§‡Æø‡Æ≤‡Øà ‡Æí‡Æ≤‡Æø‡ÆØ‡Ææ‡Æï‡Æï‡Øç ‡Æï‡Øá‡Æü‡Øç‡Æï‡Æ≤‡Ææ‡ÆÆ‡Øç.",
      greet: "‡Æµ‡Æ£‡Æï‡Øç‡Æï‡ÆÆ‡Øç! ‡Æâ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‡Æ§‡Æô‡Øç‡Æï‡ØÅ‡ÆÆ‡Æø‡Æü‡ÆÆ‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ§‡Øç‡Æ§‡ØÅ ‡Æé‡Æ§‡Øà‡ÆØ‡ØÅ‡ÆÆ‡Øç ‡Æï‡Øá‡Æ≥‡ØÅ‡Æô‡Øç‡Æï‡Æ≥‡Øç ‚Äî Wi-Fi, check-in/out, house rules, ‡ÆÆ‡Æ±‡Øç‡Æ±‡ØÅ‡ÆÆ‡Øç ‡Æâ‡Æ≥‡Øç‡Æ≥‡ØÇ‡Æ∞‡Øç ‡Æï‡ØÅ‡Æ±‡Æø‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øç.",
      missingApt: "‡Æá‡Æ®‡Øç‡Æ§ ‡Æ™‡Æï‡Øç‡Æï‡Æ§‡Øç‡Æ§‡Æø‡Æ±‡Øç‡Æï‡ØÅ apartment code ‡Æ§‡Øá‡Æµ‡Øà. ‡Æâ‡Æ§‡Ææ‡Æ∞‡Æ£‡ÆÆ‡Øç: ?apt=YAKA01",
      missingAptLong: "‡Æá‡Æ®‡Øç‡Æ§ ‡Æ≤‡Æø‡Æô‡Øç‡Æï‡Æø‡Æ≤‡Øç apartment code ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà. QR code ‡Æê scan ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æµ‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ?apt=YAKA01 ‡Æâ‡Æü‡Æ©‡Øç ‡Æ§‡Æø‡Æ±‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç.",
      speak: "üîä Speak",
      stop: "‚èπ Stop",
      generating: "‡Æâ‡Æ∞‡ØÅ‡Æµ‡Ææ‡Æï‡Øç‡Æï‡ØÅ‡Æï‡Æø‡Æ±‡Æ§‡ØÅ‚Ä¶",
      ttsFail: "‡Æí‡Æ≤‡Æø‡ÆØ‡Øà ‡Æá‡ÆØ‡Æï‡Øç‡Æï ‡ÆÆ‡ØÅ‡Æü‡Æø‡ÆØ‡Æµ‡Æø‡Æ≤‡Øç‡Æ≤‡Øà.",
      recNotSupported: "‡Æá‡Æ®‡Øç‡Æ§ browser ‡Æá‡Æ≤‡Øç voice recording ‡ÆÜ‡Æ§‡Æ∞‡Æµ‡ØÅ ‡Æá‡Æ≤‡Øç‡Æ≤‡Øà. ‡Æ§‡ÆØ‡Æµ‡ØÅ‡Æö‡ØÜ‡ÆØ‡Øç‡Æ§‡ØÅ ÿ™ÿß€å‡Æ™‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æµ‡ØÅ‡ÆÆ‡Øç.",
      httpsRequired: "‡ÆÆ‡Øä‡Æ™‡Øà‡Æ≤‡Æø‡Æ≤‡Øç microphone ‡Æï‡Øç‡Æï‡ØÅ HTTPS ‡Æ§‡Øá‡Æµ‡Øà. Azure HTTPS URL ‡Æê ‡Æ™‡ÆØ‡Æ©‡Øç‡Æ™‡Æü‡ØÅ‡Æ§‡Øç‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç.",
      sttFail: "STT ‡Æ§‡Øã‡Æ≤‡Øç‡Æµ‡Æø. ‡ÆÆ‡ØÄ‡Æ£‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç ‡ÆÆ‡ØÅ‡ÆØ‡Æ±‡Øç‡Æö‡Æø‡Æï‡Øç‡Æï‡Æµ‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ≤‡Øç‡Æ≤‡Æ§‡ØÅ ÿ™ÿß€å‡Æ™‡Øç ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡Æµ‡ØÅ‡ÆÆ‡Øç."
    }
  };

  function guessBrowserLang() {
    const b = (navigator.language || 'en').toLowerCase();
    if (b.startsWith('si')) return 'si';
    if (b.startsWith('ta')) return 'ta';
    return 'en';
  }

  function getUiLang() {
    const saved = localStorage.getItem('yaka_ui_lang');
    if (saved && I18N[saved]) return saved;
    return guessBrowserLang();
  }

  let uiLang = getUiLang();
  langSelect.value = uiLang;

  function t(key) {
    return (I18N[uiLang] && I18N[uiLang][key]) ? I18N[uiLang][key] : (I18N.en[key] || key);
  }

  function applyLanguageToUi() {
    document.documentElement.lang = uiLang;
    langLabel.textContent = t('langLabel');
    tagText.textContent = t('tag');
    subText.textContent = t('sub');
    msgEl.placeholder = t('placeholder');
    sendBtn.textContent = t('send');
    hintText.textContent = t('tip');

    // refresh pills without losing current values
    aptPill.textContent = apt ? `${t('aptPrefix')}: ${apt}` : `${t('aptPrefix')}: (not set)`;
    // api + mic pill will be refreshed by their own setters too
  }

  langSelect.addEventListener('change', () => {
    uiLang = langSelect.value;
    localStorage.setItem('yaka_ui_lang', uiLang);
    applyLanguageToUi();

    // add a small message telling guests what to do
    addBubble(
      uiLang === 'en'
        ? "Language updated. You can now type or speak in this language."
        : uiLang === 'si'
          ? "‡∂∑‡∑è‡∑Ç‡∑è‡∑Ä ‡∑Ä‡∑ô‡∂±‡∑É‡∑ä ‡∂ö‡∑Ö‡∑è. ‡∂Ø‡∑ê‡∂±‡∑ä ‡∂∏‡∑ö ‡∂∑‡∑è‡∑Ç‡∑è‡∑Ä‡∑ô‡∂±‡∑ä type ‡∑Ñ‡∑ù ‡∂ö‡∂≠‡∑è ‡∂ö‡∂ª‡∂±‡∑ä‡∂±."
          : "‡ÆÆ‡Øä‡Æ¥‡Æø ‡ÆÆ‡Ææ‡Æ±‡Øç‡Æ±‡Æ™‡Øç‡Æ™‡Æü‡Øç‡Æü‡Æ§‡ØÅ. ‡Æá‡Æ™‡Øç‡Æ™‡Øã‡Æ§‡ØÅ ‡Æá‡Æ®‡Øç‡Æ§ ‡ÆÆ‡Øä‡Æ¥‡Æø‡ÆØ‡Æø‡Æ≤‡Øç ÿ™ÿß€å‡Æ™‡Øç/‡Æ™‡Øá‡Æö‡Æ≤‡Ææ‡ÆÆ‡Øç.",
      'bot',
      '',
      { speak: true }
    );
  });

  // Cache TTS audio by exact reply text
  const ttsCache = new Map(); // text -> blobUrl

  // ----------------------------
  // FIX 1: Prevent overlapping TTS
  // ----------------------------
  let currentTtsAudio = null;
  let currentTtsAbort = null;

  function stopTtsPlayback() {
    if (currentTtsAudio) {
      try { currentTtsAudio.pause(); } catch {}
      try { currentTtsAudio.currentTime = 0; } catch {}
      currentTtsAudio = null;
    }
    if (currentTtsAbort) {
      try { currentTtsAbort.abort(); } catch {}
      currentTtsAbort = null;
    }
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, m => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[m]));
  }

  function linkify(text) {
    const safe = escapeHtml(text);
    const withLinks = safe.replace(/(https?:\/\/[^\s<]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
    return withLinks.replace(/\n/g, '<br>');
  }

  function setMicStatus(textKey) {
    micPill.textContent = t(textKey);
  }

  function setApiStatus(textKey) {
    apiPill.textContent = t(textKey);
  }

  function addBubble(text, who = 'bot', meta = '', options = {}) {
    const div = document.createElement('div');
    div.className = `bubble ${who}`;

    const content = document.createElement('div');
    if (who === 'bot') {
      content.innerHTML = linkify(text);
    } else {
      content.textContent = text;
    }
    div.appendChild(content);

    // Add Speak (TTS) button on bot messages
    if (who === 'bot' && options.speak === true) {
      const row = document.createElement('div');
      row.style.marginTop = '10px';

      const speakBtn = document.createElement('button');
      speakBtn.className = 'btn secondary small-btn';
      speakBtn.type = 'button';
      speakBtn.textContent = t('speak');

      const stopBtn = document.createElement('button');
      stopBtn.className = 'btn secondary small-btn';
      stopBtn.type = 'button';
      stopBtn.textContent = t('stop');
      stopBtn.onclick = () => stopTtsPlayback();

      speakBtn.onclick = async () => {
        const oldLabel = speakBtn.textContent;

        stopTtsPlayback(); // Always stop previous speech

        speakBtn.disabled = true;
        speakBtn.textContent = t('generating');

        try {
          if (ttsCache.has(text)) {
            currentTtsAudio = new Audio(ttsCache.get(text));
            currentTtsAudio.onended = () => { currentTtsAudio = null; };
            await currentTtsAudio.play();
            return;
          }

          currentTtsAbort = new AbortController();

          const r = await fetch('/api/tts', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            signal: currentTtsAbort.signal,
            body: JSON.stringify({ text })
          });

          if (!r.ok) throw new Error(await r.text());

          const blob = await r.blob();
          const url = URL.createObjectURL(blob);
          ttsCache.set(text, url);

          currentTtsAudio = new Audio(url);
          currentTtsAudio.onended = () => { currentTtsAudio = null; };
          await currentTtsAudio.play();
        } catch (e) {
          if (e?.name !== 'AbortError') {
            alert(t('ttsFail') + " " + (e.message || e));
          }
        } finally {
          currentTtsAbort = null;
          speakBtn.disabled = false;
          speakBtn.textContent = oldLabel;
        }
      };

      row.appendChild(speakBtn);
      row.appendChild(stopBtn);
      div.appendChild(row);
    }

    if (meta) {
      const m = document.createElement('div');
      m.className = 'meta';
      m.textContent = meta;
      div.appendChild(m);
    }

    chatEl.appendChild(div);
    chatEl.scrollTop = chatEl.scrollHeight;
  }

  async function pingApi() {
    try {
      const res = await fetch('/', { method: 'GET' });
      setApiStatus(res.ok ? 'apiOk' : 'apiNotReady');
    } catch (e) {
      setApiStatus('apiOffline');
    }
  }

  async function sendMessage(text) {
    const message = (text ?? msgEl.value).trim();
    if (!message) return;

    if (!apt) {
      addBubble(t('missingAptLong'), 'bot', '', { speak: true });
      return;
    }

    if (!text) msgEl.value = '';
    addBubble(message, 'me');

    sendBtn.disabled = true;
    micBtn.disabled = true;

    try {
      const res = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ apt, message })
      });

      if (!res.ok) {
        const tt = await res.text();
        addBubble('Sorry ‚Äî something went wrong contacting the server.', 'bot', `HTTP ${res.status}: ${tt.slice(0, 160)}`, { speak: true });
        return;
      }

      const data = await res.json();
      const reply = data.reply || 'No reply returned.';
      const meta = [
        data.source ? `source=${data.source}` : null,
        (typeof data.score === 'number') ? `score=${data.score.toFixed(2)}` : null,
        data.detected_language ? `lang=${data.detected_language}` : null
      ].filter(Boolean).join(' ‚Ä¢ ');

      addBubble(reply, 'bot', meta, { speak: true });
    } catch (e) {
      addBubble('Sorry ‚Äî could not reach the server. Is it running?', 'bot', e.message || String(e), { speak: true });
    } finally {
      sendBtn.disabled = false;
      micBtn.disabled = false;
      msgEl.focus();
    }
  }

  sendBtn.addEventListener('click', () => sendMessage());
  msgEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') sendMessage();
  });

  // -----------------------
  // MediaRecorder Voice STT
  // -----------------------
  let mediaRecorder = null;
  let chunks = [];
  let isRecording = false;
  let activeMimeType = '';

  function getBestRecorderMimeType() {
    const candidates = [
      'audio/webm;codecs=opus',
      'audio/webm',
      'audio/mp4',
      'audio/mpeg'
    ];
    if (!window.MediaRecorder || !MediaRecorder.isTypeSupported) return '';
    for (const t0 of candidates) {
      try { if (MediaRecorder.isTypeSupported(t0)) return t0; } catch {}
    }
    return '';
  }

  function extensionForMime(mime) {
    const m = (mime || '').toLowerCase();
    if (m.includes('mp4')) return 'mp4';
    if (m.includes('mpeg')) return 'mp3';
    return 'webm';
  }

  async function startRecording() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      setMicStatus('micUnsupported');
      addBubble(t('recNotSupported'), 'bot', '', { speak: true });
      return;
    }

    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
      setMicStatus('micNeedsHttps');
      addBubble(t('httpsRequired'), 'bot', '', { speak: true });
      return;
    }

    if (!window.MediaRecorder) {
      setMicStatus('micUnsupported');
      addBubble(t('recNotSupported'), 'bot', '', { speak: true });
      return;
    }

    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    chunks = [];

    activeMimeType = getBestRecorderMimeType();
    try {
      mediaRecorder = activeMimeType
        ? new MediaRecorder(stream, { mimeType: activeMimeType })
        : new MediaRecorder(stream);
    } catch (e) {
      mediaRecorder = new MediaRecorder(stream);
      activeMimeType = mediaRecorder.mimeType || '';
    }

    mediaRecorder.ondataavailable = (e) => {
      if (e.data && e.data.size > 0) chunks.push(e.data);
    };

    mediaRecorder.onstop = async () => {
      stream.getTracks().forEach(tk => tk.stop());

      setMicStatus('micTranscribing');

      try {
        const mime = mediaRecorder.mimeType || activeMimeType || 'audio/webm';
        const ext = extensionForMime(mime);

        const blob = new Blob(chunks, { type: mime });
        const fd = new FormData();
        fd.append('audio', blob, `audio.${ext}`);

        const r = await fetch('/api/stt', { method: 'POST', body: fd });
        if (!r.ok) {
          const errText = await r.text();
          throw new Error(errText || `HTTP ${r.status}`);
        }

        const data = await r.json();
        const text = (data.text || '').trim();

        if (!text) {
          addBubble("Sorry ‚Äî I couldn't hear that. Please try again.", 'bot', '', { speak: true });
          setMicStatus('micReady');
          return;
        }

        setMicStatus('micReady');
        await sendMessage(text);
      } catch (e) {
        setMicStatus('micError');
        addBubble(t('sttFail'), 'bot', e.message || String(e), { speak: true });
        setMicStatus('micReady');
      }
    };

    mediaRecorder.start();
    setMicStatus('micRecording');
  }

  function stopRecording() {
    if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
  }

  micBtn.addEventListener('click', async () => {
    try {
      if (!isRecording) {
        isRecording = true;
        micBtn.textContent = '‚èπÔ∏è';
        await startRecording();
      } else {
        isRecording = false;
        micBtn.textContent = 'üéôÔ∏è';
        stopRecording();
      }
    } catch (e) {
      isRecording = false;
      micBtn.textContent = 'üéôÔ∏è';
      setMicStatus('micError');
      addBubble('Could not start recording.', 'bot', e.message || String(e), { speak: true });
      setMicStatus('micReady');
    }
  });

  // Apply language to UI first
  applyLanguageToUi();

  // Initial UX bubbles (in selected UI language)
  addBubble(t('greet'), 'bot', '', { speak: true });
  if (!apt) addBubble(t('missingApt'), 'bot', '', { speak: true });

  setMicStatus('micReady');
  setApiStatus('apiChecking');
  pingApi();
  msgEl.focus();
</script>

</body>
</html>
